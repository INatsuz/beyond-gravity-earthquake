{
  "version": 3,
  "sources": ["../../react-window/lib/utils/isRtl.ts", "../../react-window/lib/core/useIsRtl.ts", "../../react-window/lib/hooks/useIsomorphicLayoutEffect.ts", "../../react-window/lib/utils/parseNumericStyleValue.ts", "../../react-window/lib/hooks/useResizeObserver.ts", "../../react-window/lib/hooks/useStableCallback.ts", "../../react-window/lib/utils/getRTLOffsetType.ts", "../../react-window/lib/utils/adjustScrollOffsetForRtl.ts", "../../react-window/lib/utils/assert.ts", "../../react-window/lib/core/getEstimatedSize.ts", "../../react-window/lib/core/getOffsetForIndex.ts", "../../react-window/lib/core/getStartStopIndices.ts", "../../react-window/lib/core/createCachedBounds.ts", "../../react-window/lib/core/useCachedBounds.ts", "../../react-window/lib/core/useItemSize.ts", "../../react-window/lib/core/useVirtualizer.ts", "../../react-window/lib/hooks/useMemoizedObject.ts", "../../react-window/lib/utils/shallowCompare.ts", "../../react-window/lib/utils/arePropsEqual.ts", "../../react-window/lib/components/grid/Grid.tsx", "../../react-window/lib/components/grid/useGridCallbackRef.ts", "../../react-window/lib/components/grid/useGridRef.ts", "../../react-window/lib/components/list/List.tsx", "../../react-window/lib/components/list/useListCallbackRef.ts", "../../react-window/lib/components/list/useListRef.ts", "../../react-window/lib/utils/getScrollbarSize.ts"],
  "sourcesContent": ["export function isRtl(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n  while (currentElement) {\n    if (currentElement.dir) {\n      return currentElement.dir === \"rtl\";\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return false;\n}\n", "import { useLayoutEffect, useState, type HTMLAttributes } from \"react\";\nimport { isRtl } from \"../utils/isRtl\";\n\nexport function useIsRtl(\n  element: HTMLElement | null,\n  dir: HTMLAttributes<HTMLElement>[\"dir\"]\n) {\n  const [value, setValue] = useState(dir === \"rtl\");\n\n  useLayoutEffect(() => {\n    if (element) {\n      if (!dir) {\n        setValue(isRtl(element));\n      }\n    }\n  }, [dir, element]);\n\n  return value;\n}\n", "import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n", "import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n", "import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style?: CSSProperties;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n", "import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n", "export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n", "import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n", "export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n", "import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n", "import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n", "import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): [number, number] {\n  const maxIndex = itemCount - 1;\n\n  let startIndex = 0;\n  let stopIndex = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndex = currentIndex;\n  startIndex = Math.max(0, startIndex - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndex = Math.min(maxIndex, currentIndex);\n  stopIndex = Math.min(itemCount - 1, stopIndex + overscanCount);\n\n  return startIndex < 0 ? [0, -1] : [startIndex, stopIndex];\n}\n", "import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n", "import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n", "import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n", "import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const [indices, setIndices] = useState([0, -1]);\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const [startIndex, stopIndex] = [\n    Math.min(itemCount - 1, indices[0]),\n    Math.min(itemCount - 1, indices[1])\n  ];\n\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (next[0] === prev[0] && next[1] === prev[1]) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      behavior = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      behavior?: ScrollBehavior;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo === \"function\") {\n          if (direction === \"horizontal\") {\n            containerElement.scrollTo({\n              left: scrollOffset,\n              behavior: behavior || undefined\n            });\n          } else {\n            containerElement.scrollTo({\n              behavior: behavior || undefined,\n              top: scrollOffset\n            });\n          }\n        } else {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (next[0] !== startIndex || next[1] !== stopIndex) {\n            setIndices(next);\n          }\n        }\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndex,\n    stopIndex\n  };\n}\n", "import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n", "import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { style: CSSProperties },\n  nextProps: { style: CSSProperties }\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    shallowCompare(prevStyle, nextStyle) && shallowCompare(prevRest, nextRest)\n  );\n}\n", "import {\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useIsRtl } from \"../../core/useIsRtl\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { GridProps } from \"./types\";\n\nexport function Grid<CellProps extends object>({\n  cellComponent: CellComponentProp,\n  cellProps: cellPropsUnstable,\n  className,\n  columnCount,\n  columnWidth,\n  defaultHeight = 0,\n  defaultWidth = 0,\n  dir,\n  gridRef,\n  onCellsRendered,\n  onResize,\n  overscanCount = 3,\n  rowCount,\n  rowHeight,\n  style,\n  ...rest\n}: GridProps<CellProps>) {\n  const cellProps = useMemoizedObject(cellPropsUnstable);\n  const CellComponent = useMemo(\n    () => memo(CellComponentProp, arePropsEqual),\n    [CellComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isRtl = useIsRtl(element, dir);\n\n  const {\n    getCellBounds: getColumnBounds,\n    getEstimatedSize: getEstimatedWidth,\n    startIndex: columnStartIndex,\n    scrollToIndex: scrollToColumnIndex,\n    stopIndex: columnStopIndex\n  } = useVirtualizer({\n    containerElement: element,\n    defaultContainerSize: defaultWidth,\n    direction: \"horizontal\",\n    isRtl,\n    itemCount: columnCount,\n    itemProps: cellProps,\n    itemSize: columnWidth,\n    onResize,\n    overscanCount\n  });\n\n  const {\n    getCellBounds: getRowBounds,\n    getEstimatedSize: getEstimatedHeight,\n    startIndex: rowStartIndex,\n    scrollToIndex: scrollToRowIndex,\n    stopIndex: rowStopIndex\n  } = useVirtualizer({\n    containerElement: element,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: cellProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    gridRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToCell({\n        behavior = \"auto\",\n        columnAlign = \"auto\",\n        columnIndex,\n        rowAlign = \"auto\",\n        rowIndex\n      }: {\n        behavior?: ScrollBehavior;\n        columnAlign?: Align;\n        columnIndex: number;\n        rowAlign?: Align;\n        rowIndex: number;\n      }) {\n        scrollToRowIndex({\n          align: rowAlign,\n          behavior,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index: rowIndex\n        });\n        scrollToColumnIndex({\n          align: columnAlign,\n          behavior,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index: columnIndex\n        });\n      },\n\n      scrollToColumn({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        scrollToColumnIndex({\n          align,\n          behavior,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index\n        });\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        scrollToRowIndex({\n          align,\n          behavior,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n      }\n    }),\n    [element, scrollToColumnIndex, scrollToRowIndex]\n  );\n\n  useEffect(() => {\n    if (\n      columnStartIndex >= 0 &&\n      columnStopIndex >= 0 &&\n      rowStartIndex >= 0 &&\n      rowStopIndex >= 0 &&\n      onCellsRendered\n    ) {\n      onCellsRendered({\n        columnStartIndex,\n        columnStopIndex,\n        rowStartIndex,\n        rowStopIndex\n      });\n    }\n  }, [\n    onCellsRendered,\n    columnStartIndex,\n    columnStopIndex,\n    rowStartIndex,\n    rowStopIndex\n  ]);\n\n  const cells = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (columnCount > 0 && rowCount > 0) {\n      for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n        const rowBounds = getRowBounds(rowIndex);\n        for (\n          let columnIndex = columnStartIndex;\n          columnIndex <= columnStopIndex;\n          columnIndex++\n        ) {\n          const columnBounds = getColumnBounds(columnIndex);\n\n          children.push(\n            <CellComponent\n              {...(cellProps as CellProps)}\n              columnIndex={columnIndex}\n              key={`${rowIndex}-${columnIndex}`}\n              rowIndex={rowIndex}\n              style={{\n                position: \"absolute\",\n                left: isRtl ? undefined : 0,\n                right: isRtl ? 0 : undefined,\n                transform: `translate(${isRtl ? -columnBounds.scrollOffset : columnBounds.scrollOffset}px, ${rowBounds.scrollOffset}px)`,\n                height: rowCount > 1 ? rowBounds.size : \"100%\",\n                width: columnBounds.size\n              }}\n            />\n          );\n        }\n      }\n    }\n    return children;\n  }, [\n    CellComponent,\n    cellProps,\n    columnCount,\n    columnStartIndex,\n    columnStopIndex,\n    getColumnBounds,\n    getRowBounds,\n    isRtl,\n    rowCount,\n    rowStartIndex,\n    rowStopIndex\n  ]);\n\n  return (\n    <div\n      role=\"grid\"\n      {...rest}\n      className={className}\n      dir={dir}\n      ref={setElement}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        ...style,\n        maxHeight: \"100%\",\n        maxWidth: \"100%\",\n        flexGrow: 1,\n        overflow: \"auto\"\n      }}\n    >\n      <div\n        className={className}\n        style={{\n          position: \"relative\",\n          height: getEstimatedHeight(),\n          width: getEstimatedWidth()\n        }}\n      >\n        {cells}\n      </div>\n    </div>\n  );\n}\n", "import { useState } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Grid component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useGridCallbackRef =\n  useState as typeof useState<GridImperativeAPI | null>;\n", "import { useRef } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Grid component.\n */\nexport const useGridRef = useRef as typeof useRef<GridImperativeAPI>;\n", "import {\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { ListProps } from \"./types\";\n\nexport function List<RowProps extends object>({\n  className,\n  defaultHeight = 0,\n  listRef,\n  onResize,\n  onRowsRendered,\n  overscanCount = 3,\n  rowComponent: RowComponentProp,\n  rowCount,\n  rowHeight,\n  rowProps: rowPropsUnstable,\n  style,\n  ...rest\n}: ListProps<RowProps>) {\n  const rowProps = useMemoizedObject(rowPropsUnstable);\n  const RowComponent = useMemo(\n    () => memo(RowComponentProp, arePropsEqual),\n    [RowComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndex,\n    stopIndex\n  } = useVirtualizer({\n    containerElement: element,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: rowProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    listRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        scrollToIndex({\n          align,\n          behavior,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n      }\n    }),\n    [element, scrollToIndex]\n  );\n\n  useEffect(() => {\n    if (startIndex >= 0 && stopIndex >= 0 && onRowsRendered) {\n      onRowsRendered({\n        startIndex,\n        stopIndex\n      });\n    }\n  }, [onRowsRendered, startIndex, stopIndex]);\n\n  const rows = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (rowCount > 0) {\n      for (let index = startIndex; index <= stopIndex; index++) {\n        const bounds = getCellBounds(index);\n\n        children.push(\n          <RowComponent\n            {...(rowProps as RowProps)}\n            key={index}\n            index={index}\n            style={{\n              position: \"absolute\",\n              left: 0,\n              transform: `translateY(${bounds.scrollOffset}px)`,\n              height: bounds.size,\n              width: \"100%\"\n            }}\n          />\n        );\n      }\n    }\n    return children;\n  }, [RowComponent, getCellBounds, rowCount, rowProps, startIndex, stopIndex]);\n\n  return (\n    <div\n      role=\"list\"\n      {...rest}\n      className={className}\n      ref={setElement}\n      style={{\n        ...style,\n        maxHeight: \"100%\",\n        flexGrow: 1,\n        overflowY: \"auto\"\n      }}\n    >\n      <div\n        className={className}\n        style={{\n          height: getEstimatedSize(),\n          position: \"relative\",\n          width: \"100%\"\n        }}\n      >\n        {rows}\n      </div>\n    </div>\n  );\n}\n", "import { useState } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the List component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useListCallbackRef =\n  useState as typeof useState<ListImperativeAPI | null>;\n", "import { useRef } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the List component.\n */\nexport const useListRef = useRef as typeof useRef<ListImperativeAPI>;\n", "let size: number = -1;\n\nexport function getScrollbarSize(recalculate: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement(\"div\");\n    const style = div.style;\n    style.width = \"50px\";\n    style.height = \"50px\";\n    style.overflow = \"scroll\";\n\n    document.body.appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nexport function setScrollbarSizeForTests(value: number) {\n  size = value;\n}\n"],
  "mappings": "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",
  "names": ["isRtl", "element", "currentElement", "useIsRtl", "dir", "value", "setValue", "useState", "useLayoutEffect", "useIsomorphicLayoutEffect", "useEffect", "parseNumericStyleValue", "useResizeObserver", "box", "defaultHeight", "defaultWidth", "disabledProp", "mode", "style", "styleHeight", "styleWidth", "useMemo", "state", "setState", "disabled", "resizeObserver", "entries", "entry", "contentRect", "target", "prevState", "useStableCallback", "fn", "ref", "useRef", "useCallback", "args", "cachedRTLResult", "getRTLOffsetType", "recalculate", "outerDiv", "outerStyle", "innerDiv", "innerStyle", "adjustScrollOffsetForRtl", "containerElement", "direction", "scrollOffset", "clientWidth", "scrollLeft", "scrollWidth", "assert", "expectedCondition", "message", "getEstimatedSize", "cachedBounds", "itemCount", "itemSize", "bounds", "averageItemSize", "getOffsetForIndex", "align", "index", "containerScrollOffset", "containerSize", "estimatedTotalSize", "maxOffset", "minOffset", "getStartStopIndices", "overscanCount", "maxIndex", "startIndex", "stopIndex", "currentIndex", "createCachedBounds", "itemProps", "cache", "size", "previousRowBounds", "useCachedBounds", "useItemSize", "itemSizeProp", "useVirtualizer", "containerStyle", "defaultContainerSize", "onResize", "indices", "setIndices", "height", "width", "prevSizeRef", "prevSize", "getCellBounds", "getEstimatedSizeUtil", "getStartStopIndicesUtil", "onScroll", "prev", "scrollTop", "next", "scrollToIndex", "behavior", "useMemoizedObject", "unstableObject", "shallowCompare", "a", "b", "key", "arePropsEqual", "prevProps", "nextProps", "prevStyle", "prevRest", "nextStyle", "nextRest", "Grid", "CellComponentProp", "cellPropsUnstable", "className", "columnCount", "columnWidth", "gridRef", "onCellsRendered", "rowCount", "rowHeight", "rest", "cellProps", "CellComponent", "memo", "setElement", "getColumnBounds", "getEstimatedWidth", "columnStartIndex", "scrollToColumnIndex", "columnStopIndex", "getRowBounds", "getEstimatedHeight", "rowStartIndex", "scrollToRowIndex", "rowStopIndex", "useImperativeHandle", "columnAlign", "columnIndex", "rowAlign", "rowIndex", "cells", "children", "rowBounds", "columnBounds", "createElement", "jsx", "useGridCallbackRef", "useGridRef", "List", "listRef", "onRowsRendered", "RowComponentProp", "rowPropsUnstable", "rowProps", "RowComponent", "rows", "useListCallbackRef", "useListRef", "getScrollbarSize", "div"]
}
