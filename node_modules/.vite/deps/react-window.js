import {
  require_jsx_runtime
} from "./chunk-XO4JX7VM.js";
import {
  require_react
} from "./chunk-PSQR3SVX.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/react-window/dist/react-window.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
function ie(e) {
  let t = e;
  for (; t; ) {
    if (t.dir)
      return t.dir === "rtl";
    t = t.parentElement;
  }
  return false;
}
function le(e, t) {
  const [s, r] = (0, import_react.useState)(t === "rtl");
  return (0, import_react.useLayoutEffect)(() => {
    e && (t || r(ie(e)));
  }, [t, e]), s;
}
var Y = typeof window < "u" ? import_react.useLayoutEffect : import_react.useEffect;
function Q(e) {
  if (e !== void 0)
    switch (typeof e) {
      case "number":
        return e;
      case "string": {
        if (e.endsWith("px"))
          return parseFloat(e);
        break;
      }
    }
}
function ne({
  box: e,
  defaultHeight: t,
  defaultWidth: s,
  disabled: r,
  element: o,
  mode: i,
  style: n
}) {
  const { styleHeight: c, styleWidth: l } = (0, import_react.useMemo)(
    () => ({
      styleHeight: Q(n?.height),
      styleWidth: Q(n?.width)
    }),
    [n?.height, n?.width]
  ), [f, a] = (0, import_react.useState)({
    height: t,
    width: s
  }), I = r || i === "only-height" && c !== void 0 || i === "only-width" && l !== void 0 || c !== void 0 && l !== void 0;
  return Y(() => {
    if (o === null || I)
      return;
    const v = new ResizeObserver((k) => {
      for (const x of k) {
        const { contentRect: w, target: z } = x;
        o === z && a((g) => g.height === w.height && g.width === w.width ? g : {
          height: w.height,
          width: w.width
        });
      }
    });
    return v.observe(o, { box: e }), () => {
      v?.unobserve(o);
    };
  }, [e, I, o, c, l]), (0, import_react.useMemo)(
    () => ({
      height: c ?? f.height,
      width: l ?? f.width
    }),
    [f, c, l]
  );
}
function ce(e) {
  const t = (0, import_react.useRef)(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  return Y(() => {
    t.current = e;
  }, [e]), (0, import_react.useCallback)((s) => t.current?.(s), [t]);
}
var j = null;
function fe(e = false) {
  if (j === null || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", s.direction = "rtl";
    const r = document.createElement("div"), o = r.style;
    return o.width = "100px", o.height = "100px", t.appendChild(r), document.body.appendChild(t), t.scrollLeft > 0 ? j = "positive-descending" : (t.scrollLeft = 1, t.scrollLeft === 0 ? j = "negative" : j = "positive-ascending"), document.body.removeChild(t), j;
  }
  return j;
}
function A({
  containerElement: e,
  direction: t,
  isRtl: s,
  scrollOffset: r
}) {
  if (t === "horizontal" && s)
    switch (fe()) {
      case "negative":
        return -r;
      case "positive-descending": {
        if (e) {
          const { clientWidth: o, scrollLeft: i, scrollWidth: n } = e;
          return n - o - i;
        }
        break;
      }
    }
  return r;
}
function R(e, t = "Assertion error") {
  if (!e)
    throw console.error(t), Error(t);
}
function te({
  cachedBounds: e,
  itemCount: t,
  itemSize: s
}) {
  if (t === 0)
    return 0;
  if (typeof s == "number")
    return t * s;
  {
    const r = e.get(
      e.size === 0 ? 0 : e.size - 1
    );
    R(r !== void 0, "Unexpected bounds cache miss");
    const o = (r.scrollOffset + r.size) / e.size;
    return t * o;
  }
}
function de({
  align: e,
  cachedBounds: t,
  index: s,
  itemCount: r,
  itemSize: o,
  containerScrollOffset: i,
  containerSize: n
}) {
  const c = te({
    cachedBounds: t,
    itemCount: r,
    itemSize: o
  }), l = t.get(s), f = Math.max(
    0,
    Math.min(c - n, l.scrollOffset)
  ), a = Math.max(
    0,
    l.scrollOffset - n + l.size
  );
  switch (e === "smart" && (i >= a && i <= f ? e = "auto" : e = "center"), e) {
    case "start":
      return f;
    case "end":
      return a;
    case "center":
      return l.scrollOffset <= n / 2 ? 0 : l.scrollOffset + l.size / 2 >= c - n / 2 ? c - n : l.scrollOffset + l.size / 2 - n / 2;
    case "auto":
    default:
      return i >= a && i <= f ? i : i < a ? a : f;
  }
}
function X({
  cachedBounds: e,
  containerScrollOffset: t,
  containerSize: s,
  itemCount: r,
  overscanCount: o
}) {
  const i = r - 1;
  let n = 0, c = -1, l = 0;
  for (; l < i; ) {
    const f = e.get(l);
    if (f.scrollOffset + f.size > t)
      break;
    l++;
  }
  for (n = l, n = Math.max(0, n - o); l < i; ) {
    const f = e.get(l);
    if (f.scrollOffset + f.size >= t + s)
      break;
    l++;
  }
  return c = Math.min(i, l), c = Math.min(r - 1, c + o), n < 0 ? [0, -1] : [n, c];
}
function ue({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  const r = /* @__PURE__ */ new Map();
  return {
    get(o) {
      for (R(o < e, `Invalid index ${o}`); r.size - 1 < o; ) {
        const n = r.size;
        let c;
        switch (typeof s) {
          case "function": {
            c = s(n, t);
            break;
          }
          case "number": {
            c = s;
            break;
          }
        }
        if (n === 0)
          r.set(n, {
            size: c,
            scrollOffset: 0
          });
        else {
          const l = r.get(n - 1);
          R(
            l !== void 0,
            `Unexpected bounds cache miss for index ${o}`
          ), r.set(n, {
            scrollOffset: l.scrollOffset + l.size,
            size: c
          });
        }
      }
      const i = r.get(o);
      return R(
        i !== void 0,
        `Unexpected bounds cache miss for index ${o}`
      ), i;
    },
    set(o, i) {
      r.set(o, i);
    },
    get size() {
      return r.size;
    }
  };
}
function he({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  return (0, import_react.useMemo)(
    () => ue({
      itemCount: e,
      itemProps: t,
      itemSize: s
    }),
    [e, t, s]
  );
}
function ae({
  containerSize: e,
  itemSize: t
}) {
  let s;
  switch (typeof t) {
    case "string": {
      R(
        t.endsWith("%"),
        `Invalid item size: "${t}"; string values must be percentages (e.g. "100%")`
      ), R(
        e !== void 0,
        "Container size must be defined if a percentage item size is specified"
      ), s = e * parseInt(t) / 100;
      break;
    }
    default: {
      s = t;
      break;
    }
  }
  return s;
}
function C({
  containerElement: e,
  containerStyle: t,
  defaultContainerSize: s = 0,
  direction: r,
  isRtl: o = false,
  itemCount: i,
  itemProps: n,
  itemSize: c,
  onResize: l,
  overscanCount: f
}) {
  const [a, I] = (0, import_react.useState)([0, -1]), [v, k] = [
    Math.min(i - 1, a[0]),
    Math.min(i - 1, a[1])
  ], { height: x = s, width: w = s } = ne({
    defaultHeight: r === "vertical" ? s : void 0,
    defaultWidth: r === "horizontal" ? s : void 0,
    element: e,
    mode: r === "vertical" ? "only-height" : "only-width",
    style: t
  }), z = (0, import_react.useRef)({
    height: 0,
    width: 0
  }), g = r === "vertical" ? x : w, u = ae({ containerSize: g, itemSize: c });
  (0, import_react.useLayoutEffect)(() => {
    if (typeof l == "function") {
      const d = z.current;
      (d.height !== x || d.width !== w) && (l({ height: x, width: w }, { ...d }), d.height = x, d.width = w);
    }
  }, [x, l, w]);
  const h = he({
    itemCount: i,
    itemProps: n,
    itemSize: u
  }), y = (0, import_react.useCallback)(
    (d) => h.get(d),
    [h]
  ), B = (0, import_react.useCallback)(
    () => te({
      cachedBounds: h,
      itemCount: i,
      itemSize: u
    }),
    [h, i, u]
  ), T = (0, import_react.useCallback)(
    (d) => {
      const m = A({
        containerElement: e,
        direction: r,
        isRtl: o,
        scrollOffset: d
      });
      return X({
        cachedBounds: h,
        containerScrollOffset: m,
        containerSize: g,
        itemCount: i,
        overscanCount: f
      });
    },
    [
      h,
      e,
      g,
      r,
      o,
      i,
      f
    ]
  );
  Y(() => {
    const d = (r === "vertical" ? e?.scrollTop : e?.scrollLeft) ?? 0;
    I(T(d));
  }, [e, r, T]), Y(() => {
    if (!e)
      return;
    const d = () => {
      I((m) => {
        const { scrollLeft: H, scrollTop: G } = e, b = A({
          containerElement: e,
          direction: r,
          isRtl: o,
          scrollOffset: r === "vertical" ? G : H
        }), O = X({
          cachedBounds: h,
          containerScrollOffset: b,
          containerSize: g,
          itemCount: i,
          overscanCount: f
        });
        return O[0] === m[0] && O[1] === m[1] ? m : O;
      });
    };
    return e.addEventListener("scroll", d), () => {
      e.removeEventListener("scroll", d);
    };
  }, [
    h,
    e,
    g,
    r,
    i,
    f
  ]);
  const p = ce(
    ({
      align: d = "auto",
      behavior: m = "auto",
      containerScrollOffset: H,
      index: G
    }) => {
      let b = de({
        align: d,
        cachedBounds: h,
        containerScrollOffset: H,
        containerSize: g,
        index: G,
        itemCount: i,
        itemSize: u
      });
      if (e)
        if (b = A({
          containerElement: e,
          direction: r,
          isRtl: o,
          scrollOffset: b
        }), typeof e.scrollTo == "function")
          r === "horizontal" ? e.scrollTo({
            left: b,
            behavior: m || void 0
          }) : e.scrollTo({
            behavior: m || void 0,
            top: b
          });
        else {
          const O = T(b);
          (O[0] !== v || O[1] !== k) && I(O);
        }
    }
  );
  return {
    getCellBounds: y,
    getEstimatedSize: B,
    scrollToIndex: p,
    startIndex: v,
    stopIndex: k
  };
}
function se(e) {
  return (0, import_react.useMemo)(() => e, Object.values(e));
}
function Z(e, t) {
  if (e === t)
    return true;
  if (!!e != !!t || (R(e !== void 0), R(t !== void 0), Object.keys(e).length !== Object.keys(t).length))
    return false;
  for (const s in e)
    if (!Object.is(t[s], e[s]))
      return false;
  return true;
}
function re(e, t) {
  const { style: s, ...r } = e, { style: o, ...i } = t;
  return Z(s, o) && Z(r, i);
}
function ve({
  cellComponent: e,
  cellProps: t,
  className: s,
  columnCount: r,
  columnWidth: o,
  defaultHeight: i = 0,
  defaultWidth: n = 0,
  dir: c,
  gridRef: l,
  onCellsRendered: f,
  onResize: a,
  overscanCount: I = 3,
  rowCount: v,
  rowHeight: k,
  style: x,
  ...w
}) {
  const z = se(t), g = (0, import_react.useMemo)(
    () => (0, import_react.memo)(e, re),
    [e]
  ), [u, h] = (0, import_react.useState)(null), y = le(u, c), {
    getCellBounds: B,
    getEstimatedSize: T,
    startIndex: p,
    scrollToIndex: d,
    stopIndex: m
  } = C({
    containerElement: u,
    defaultContainerSize: n,
    direction: "horizontal",
    isRtl: y,
    itemCount: r,
    itemProps: z,
    itemSize: o,
    onResize: a,
    overscanCount: I
  }), {
    getCellBounds: H,
    getEstimatedSize: G,
    startIndex: b,
    scrollToIndex: O,
    stopIndex: F
  } = C({
    containerElement: u,
    defaultContainerSize: i,
    direction: "vertical",
    itemCount: v,
    itemProps: z,
    itemSize: k,
    onResize: a,
    overscanCount: I
  });
  (0, import_react.useImperativeHandle)(
    l,
    () => ({
      get element() {
        return u;
      },
      scrollToCell({
        behavior: L = "auto",
        columnAlign: S = "auto",
        columnIndex: M,
        rowAlign: $ = "auto",
        rowIndex: U
      }) {
        O({
          align: $,
          behavior: L,
          containerScrollOffset: u?.scrollTop ?? 0,
          index: U
        }), d({
          align: S,
          behavior: L,
          containerScrollOffset: u?.scrollLeft ?? 0,
          index: M
        });
      },
      scrollToColumn({
        align: L = "auto",
        behavior: S = "auto",
        index: M
      }) {
        d({
          align: L,
          behavior: S,
          containerScrollOffset: u?.scrollLeft ?? 0,
          index: M
        });
      },
      scrollToRow({
        align: L = "auto",
        behavior: S = "auto",
        index: M
      }) {
        O({
          align: L,
          behavior: S,
          containerScrollOffset: u?.scrollTop ?? 0,
          index: M
        });
      }
    }),
    [u, d, O]
  ), (0, import_react.useEffect)(() => {
    p >= 0 && m >= 0 && b >= 0 && F >= 0 && f && f({
      columnStartIndex: p,
      columnStopIndex: m,
      rowStartIndex: b,
      rowStopIndex: F
    });
  }, [
    f,
    p,
    m,
    b,
    F
  ]);
  const oe = (0, import_react.useMemo)(() => {
    const L = [];
    if (r > 0 && v > 0)
      for (let S = b; S <= F; S++) {
        const M = H(S);
        for (let $ = p; $ <= m; $++) {
          const U = B($);
          L.push(
            (0, import_react.createElement)(
              g,
              {
                ...z,
                columnIndex: $,
                key: `${S}-${$}`,
                rowIndex: S,
                style: {
                  position: "absolute",
                  left: y ? void 0 : 0,
                  right: y ? 0 : void 0,
                  transform: `translate(${y ? -U.scrollOffset : U.scrollOffset}px, ${M.scrollOffset}px)`,
                  height: v > 1 ? M.size : "100%",
                  width: U.size
                }
              }
            )
          );
        }
      }
    return L;
  }, [
    g,
    z,
    r,
    p,
    m,
    B,
    H,
    y,
    v,
    b,
    F
  ]);
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      role: "grid",
      ...w,
      className: s,
      dir: c,
      ref: h,
      style: {
        width: "100%",
        height: "100%",
        ...x,
        maxHeight: "100%",
        maxWidth: "100%",
        flexGrow: 1,
        overflow: "auto"
      },
      children: (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: s,
          style: {
            position: "relative",
            height: G(),
            width: T()
          },
          children: oe
        }
      )
    }
  );
}
var xe = import_react.useState;
var we = import_react.useRef;
function me({
  className: e,
  defaultHeight: t = 0,
  listRef: s,
  onResize: r,
  onRowsRendered: o,
  overscanCount: i = 3,
  rowComponent: n,
  rowCount: c,
  rowHeight: l,
  rowProps: f,
  style: a,
  ...I
}) {
  const v = se(f), k = (0, import_react.useMemo)(
    () => (0, import_react.memo)(n, re),
    [n]
  ), [x, w] = (0, import_react.useState)(null), {
    getCellBounds: z,
    getEstimatedSize: g,
    scrollToIndex: u,
    startIndex: h,
    stopIndex: y
  } = C({
    containerElement: x,
    defaultContainerSize: t,
    direction: "vertical",
    itemCount: c,
    itemProps: v,
    itemSize: l,
    onResize: r,
    overscanCount: i
  });
  (0, import_react.useImperativeHandle)(
    s,
    () => ({
      get element() {
        return x;
      },
      scrollToRow({
        align: T = "auto",
        behavior: p = "auto",
        index: d
      }) {
        u({
          align: T,
          behavior: p,
          containerScrollOffset: x?.scrollTop ?? 0,
          index: d
        });
      }
    }),
    [x, u]
  ), (0, import_react.useEffect)(() => {
    h >= 0 && y >= 0 && o && o({
      startIndex: h,
      stopIndex: y
    });
  }, [o, h, y]);
  const B = (0, import_react.useMemo)(() => {
    const T = [];
    if (c > 0)
      for (let p = h; p <= y; p++) {
        const d = z(p);
        T.push(
          (0, import_react.createElement)(
            k,
            {
              ...v,
              key: p,
              index: p,
              style: {
                position: "absolute",
                left: 0,
                transform: `translateY(${d.scrollOffset}px)`,
                height: d.size,
                width: "100%"
              }
            }
          )
        );
      }
    return T;
  }, [k, z, c, v, h, y]);
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      role: "list",
      ...I,
      className: e,
      ref: w,
      style: {
        ...a,
        maxHeight: "100%",
        flexGrow: 1,
        overflowY: "auto"
      },
      children: (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: e,
          style: {
            height: g(),
            position: "relative",
            width: "100%"
          },
          children: B
        }
      )
    }
  );
}
var ye = import_react.useState;
var be = import_react.useRef;
var P = -1;
function Ie(e = false) {
  if (P === -1 || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", document.body.appendChild(t), P = t.offsetWidth - t.clientWidth, document.body.removeChild(t);
  }
  return P;
}
export {
  ve as Grid,
  me as List,
  Ie as getScrollbarSize,
  xe as useGridCallbackRef,
  we as useGridRef,
  ye as useListCallbackRef,
  be as useListRef
};
//# sourceMappingURL=react-window.js.map
